<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Simulador DFS - Compara√ß√£o Recursivo vs Iterativo</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
  .container { max-width: 1600px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  h2 { color: #333; }
  .controls { margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 5px; }
  label { font-weight: bold; margin-right: 10px; }
  input[type=number] { width: 80px; font-size: 16px; padding: 5px; margin-right: 15px; }
  button { font-size: 16px; padding: 8px 15px; margin: 5px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; }
  button:hover { background: #45a049; }
  button:disabled { background: #ccc; cursor: not-allowed; }
  .step-button { background: #2196F3; }
  .step-button:hover { background: #0b7dda; }
  .reset-button { background: #f44336; }
  .reset-button:hover { background: #da190b; }
  .version-button { background: #9C27B0; }
  .version-button:hover { background: #7B1FA2; }
  .version-button.active { background: #6A1B9A; border: 3px solid #4A148C; }
  .comparison-button { background: #FF6F00; }
  .comparison-button:hover { background: #E65100; }
  .comparison-button.active { background: #D84315; border: 3px solid #BF360C; }
  
  .single-mode .canvas-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  .single-mode .canvas-wrapper { overflow: auto; max-height: 500px; border: 2px solid #ddd; background: white; }
  .single-mode canvas { display: block; margin: 0; }
  .single-mode #stack-canvas { grid-column: 1 / -1; }
  
  .comparison-mode .comparison-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
  .comparison-mode .comparison-section { border: 2px solid #ddd; border-radius: 8px; padding: 15px; background: #fafafa; }
  .comparison-mode .section-title { font-weight: bold; font-size: 18px; color: #fff; padding: 10px; margin: -15px -15px 15px -15px; border-radius: 6px 6px 0 0; text-align: center; }
  .comparison-mode .recursive-title { background: #6A1B9A; }
  .comparison-mode .iterative-title { background: #D84315; }
  .comparison-mode .canvas-wrapper { overflow: auto; max-height: 400px; border: 2px solid #ddd; background: white; margin: 10px 0; }
  .comparison-mode canvas { display: block; margin: 0; }
  .comparison-mode .stack-comparison { grid-column: 1 / -1; }
  .comparison-mode .output-comparison { grid-column: 1 / -1; }
  
  .canvas-label { font-weight: bold; color: #555; margin-top: 10px; margin-bottom: 5px; }
  #output { margin-top: 20px; white-space: pre-wrap; font-family: monospace; border: 1px solid #ddd; padding: 15px; background: #f9f9f9; max-height: 300px; overflow-y: auto; font-size: 14px; }
  .output-box { white-space: pre-wrap; font-family: monospace; border: 1px solid #ddd; padding: 15px; background: #f9f9f9; max-height: 250px; overflow-y: auto; font-size: 13px; margin-top: 10px; }
  .state-display { margin: 15px 0; padding: 15px; background: #e3f2fd; border-left: 4px solid #2196F3; border-radius: 4px; }
  .state-display h3 { margin-top: 0; color: #1976D2; }
  .var-display { display: inline-block; margin: 5px 15px 5px 0; padding: 5px 10px; background: white; border-radius: 3px; font-family: monospace; }
  .stack-display { background: #ffe0b2; padding: 10px; border-radius: 4px; margin: 10px 0; }
  .version-info { display: inline-block; margin-left: 20px; padding: 5px 10px; background: #e1bee7; border-radius: 4px; font-size: 14px; font-weight: bold; color: #4A148C; }
  
  .hidden { display: none !important; }
</style>
</head>
<body>
<div class="container single-mode" id="mainContainer">
<h2>Simulador DFS - Busca em Profundidade <span class="version-info" id="versionInfo">Recursivo</span></h2>

<div class="controls">
  <button class="version-button active" id="recursiveBtn" onclick="setVersion('recursive')">Vers√£o Recursiva</button>
  <button class="version-button" id="iterativeBtn" onclick="setVersion('iterative')">Vers√£o Iterativa</button>
  <button class="comparison-button" id="comparisonBtn" onclick="toggleComparison()">üîç Modo Compara√ß√£o</button>
  <br><br>
  <label for="numVertices">N√∫mero de v√©rtices:</label>
  <input type="number" id="numVertices" value="8" min="3" max="12" />
  <button onclick="generateRandomGraph()">Gerar Grafo Aleat√≥rio</button>
  <button onclick="loadDefaultGraph()">Carregar Padr√£o 1</button>
  <button onclick="loadDefaultGraph2()">Carregar Padr√£o 2</button>
  <button class="step-button" id="stepBtn" onclick="stepSimulation()" disabled>Pr√≥ximo Passo</button>
  <button class="reset-button" onclick="resetSimulation()">Reiniciar</button>
</div>

<div id="singleModeLayout">
  <div class="canvas-container">
    <div>
      <div class="canvas-label">Grafo (n√£o orientado):</div>
      <div class="canvas-wrapper">
        <canvas id="graph-canvas" width="650" height="500"></canvas>
      </div>
    </div>
    <div>
      <div class="canvas-label">√Årvore de Explora√ß√£o DFS:</div>
      <div class="canvas-wrapper">
        <canvas id="tree-canvas" width="650" height="500"></canvas>
      </div>
    </div>
  </div>

  <div class="canvas-label" id="stackLabel">Pilha:</div>
  <canvas id="stack-canvas" width="1300" height="150"></canvas>

  <div class="state-display" id="stateDisplay" style="display:none;">
    <h3>Estado Atual</h3>
    <div id="variables"></div>
    <div class="stack-display">
      <strong id="stackDisplayLabel">Pilha:</strong> <span id="stackContent">[]</span>
    </div>
  </div>

  <div id="output"></div>
</div>

<div id="comparisonModeLayout" class="hidden">
  <div class="comparison-container">
    <div class="comparison-section">
      <div class="section-title recursive-title">DFS RECURSIVO</div>
      <div class="canvas-label">Grafo com Explora√ß√£o:</div>
      <div class="canvas-wrapper">
        <canvas id="graph-canvas-rec" width="600" height="400"></canvas>
      </div>
      <div class="canvas-label">√Årvore de Explora√ß√£o:</div>
      <div class="canvas-wrapper">
        <canvas id="tree-canvas-rec" width="600" height="400"></canvas>
      </div>
    </div>
    
    <div class="comparison-section">
      <div class="section-title iterative-title">DFS ITERATIVO</div>
      <div class="canvas-label">Grafo com Explora√ß√£o:</div>
      <div class="canvas-wrapper">
        <canvas id="graph-canvas-iter" width="600" height="400"></canvas>
      </div>
      <div class="canvas-label">√Årvore de Explora√ß√£o:</div>
      <div class="canvas-wrapper">
        <canvas id="tree-canvas-iter" width="600" height="400"></canvas>
      </div>
    </div>
  </div>

  <div class="comparison-container stack-comparison">
    <div class="comparison-section">
      <div class="section-title recursive-title">Pilha de Chamadas (Recursivo)</div>
      <canvas id="stack-canvas-rec" width="750" height="150"></canvas>
      <div class="state-display">
        <div id="variables-rec"></div>
        <div class="stack-display">
          <strong>Pilha:</strong> <span id="stackContent-rec">[]</span>
        </div>
      </div>
    </div>
    
    <div class="comparison-section">
      <div class="section-title iterative-title">Pilha (Iterativo)</div>
      <canvas id="stack-canvas-iter" width="750" height="150"></canvas>
      <div class="state-display">
        <div id="variables-iter"></div>
        <div class="stack-display">
          <strong>Pilha:</strong> <span id="stackContent-iter">[]</span>
        </div>
      </div>
    </div>
  </div>

  <div class="comparison-container output-comparison">
    <div class="comparison-section">
      <div class="section-title recursive-title">Passo a Passo (Recursivo)</div>
      <div class="output-box" id="output-rec"></div>
    </div>
    
    <div class="comparison-section">
      <div class="section-title iterative-title">Passo a Passo (Iterativo)</div>
      <div class="output-box" id="output-iter"></div>
    </div>
  </div>
</div>

</div>

<script>
let vertices = [];
let edges = [];
let adjList = {};
let currentGraphType = 'default1';
let comparisonMode = false;

let marked = {}, expl = {}, stack = [], cont = 0, currentVertex = null;
let steps = [], stepIndex = 0, simulationStarted = false;
let treeEdges = [], treeParent = {};
let dfsVersion = 'recursive';
let outputText = '';

let stateRec = { marked: {}, expl: {}, stack: [], cont: 0, currentVertex: null, treeEdges: [], treeParent: {}, steps: [], stepIndex: 0, output: '' };
let stateIter = { marked: {}, expl: {}, stack: [], cont: 0, currentVertex: null, treeEdges: [], treeParent: {}, steps: [], stepIndex: 0, output: '' };

let canvas, ctx, treeCanvas, treeCtx, stackCanvas, stackCtx;
let canvasRec, ctxRec, treeCanvasRec, treeCtxRec, stackCanvasRec, stackCtxRec;
let canvasIter, ctxIter, treeCanvasIter, treeCtxIter, stackCanvasIter, stackCtxIter;

function init() {
  canvas = document.getElementById('graph-canvas');
  ctx = canvas.getContext('2d');
  treeCanvas = document.getElementById('tree-canvas');
  treeCtx = treeCanvas.getContext('2d');
  stackCanvas = document.getElementById('stack-canvas');
  stackCtx = stackCanvas.getContext('2d');
  
  canvasRec = document.getElementById('graph-canvas-rec');
  ctxRec = canvasRec.getContext('2d');
  treeCanvasRec = document.getElementById('tree-canvas-rec');
  treeCtxRec = treeCanvasRec.getContext('2d');
  stackCanvasRec = document.getElementById('stack-canvas-rec');
  stackCtxRec = stackCanvasRec.getContext('2d');
  
  canvasIter = document.getElementById('graph-canvas-iter');
  ctxIter = canvasIter.getContext('2d');
  treeCanvasIter = document.getElementById('tree-canvas-iter');
  treeCtxIter = treeCanvasIter.getContext('2d');
  stackCanvasIter = document.getElementById('stack-canvas-iter');
  stackCtxIter = stackCanvasIter.getContext('2d');
  
  loadDefaultGraph2();
}

function toggleComparison() {
  comparisonMode = !comparisonMode;
  
  let container = document.getElementById('mainContainer');
  let singleLayout = document.getElementById('singleModeLayout');
  let comparisonLayout = document.getElementById('comparisonModeLayout');
  let comparisonBtn = document.getElementById('comparisonBtn');
  let versionInfo = document.getElementById('versionInfo');
  
  if (comparisonMode) {
    container.classList.remove('single-mode');
    container.classList.add('comparison-mode');
    singleLayout.classList.add('hidden');
    comparisonLayout.classList.remove('hidden');
    comparisonBtn.classList.add('active');
    comparisonBtn.textContent = '‚Üê Modo Individual';
    versionInfo.textContent = 'Compara√ß√£o';
    
    document.getElementById('recursiveBtn').disabled = true;
    document.getElementById('iterativeBtn').disabled = true;
  } else {
    container.classList.remove('comparison-mode');
    container.classList.add('single-mode');
    singleLayout.classList.remove('hidden');
    comparisonLayout.classList.add('hidden');
    comparisonBtn.classList.remove('active');
    comparisonBtn.textContent = 'üîç Modo Compara√ß√£o';
    versionInfo.textContent = dfsVersion === 'recursive' ? 'Recursivo' : 'Iterativo';
    
    document.getElementById('recursiveBtn').disabled = false;
    document.getElementById('iterativeBtn').disabled = false;
  }
  
  resetSimulation();
}

function setVersion(version) {
  if (comparisonMode) return;
  
  dfsVersion = version;
  
  document.getElementById('recursiveBtn').classList.remove('active');
  document.getElementById('iterativeBtn').classList.remove('active');
  
  if (version === 'recursive') {
    document.getElementById('recursiveBtn').classList.add('active');
    document.getElementById('versionInfo').textContent = 'Recursivo';
  } else {
    document.getElementById('iterativeBtn').classList.add('active');
    document.getElementById('versionInfo').textContent = 'Iterativo';
  }
  
  resetSimulation();
}

function loadDefaultGraph() {
  currentGraphType = 'default1';
  vertices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  let edgeList = [
    [1, 9], [1, 4], [1, 5],
    [9, 5],
    [5, 4],
    [4, 6], [4, 2], [4, 7], [4, 8],
    [6, 8],
    [8, 2], [8, 3], [8, 10],
    [2, 3], [2, 7],
    [7, 3]
  ];
  
  buildGraphFromEdges(edgeList);
}

function loadDefaultGraph2() {
  currentGraphType = 'default2';
  vertices = [1, 2, 3, 4, 5, 6, 7, 8];
  
  let edgeList = [
    [1, 2], [1, 3],
    [2, 4], [2, 5],
    [3, 6], [3, 7],
    [4, 8],
    [5, 8],
    [6, 8],
    [7, 8]
  ];
  
  buildGraphFromEdges(edgeList);
}

function generateRandomGraph() {
  currentGraphType = 'random';
  let n = parseInt(document.getElementById('numVertices').value);
  if (n < 3 || n > 12) {
    alert('Escolha entre 3 e 12 v√©rtices');
    return;
  }
  
  vertices = [];
  for (let i = 1; i <= n; i++) {
    vertices.push(i);
  }
  
  let edgeList = [];
  let connected = [1];
  let unconnected = [];
  for (let i = 2; i <= n; i++) {
    unconnected.push(i);
  }
  
  while (unconnected.length > 0) {
    let fromIdx = Math.floor(Math.random() * connected.length);
    let toIdx = Math.floor(Math.random() * unconnected.length);
    let from = connected[fromIdx];
    let to = unconnected[toIdx];
    
    edgeList.push([from, to]);
    connected.push(to);
    unconnected.splice(toIdx, 1);
  }
  
  let numExtraEdges = Math.floor(n * 0.5);
  for (let i = 0; i < numExtraEdges; i++) {
    let from = Math.floor(Math.random() * n) + 1;
    let to = Math.floor(Math.random() * n) + 1;
    
    if (from !== to && !edgeList.some(e => (e[0] === from && e[1] === to) || (e[0] === to && e[1] === from))) {
      edgeList.push([from, to]);
    }
  }
  
  buildGraphFromEdges(edgeList);
}

function buildGraphFromEdges(edgeList) {
  edges = [];
  for (let [u, v] of edgeList) {
    edges.push([u, v]);
    edges.push([v, u]);
  }
  
  adjList = {};
  for (let v of vertices) {
    adjList[v] = [];
  }
  
  for (let [u, v] of edges) {
    if (!adjList[u].includes(v)) {
      adjList[u].push(v);
    }
  }
  
  for (let v of vertices) {
    adjList[v].sort((a, b) => a - b);
  }
  
  drawGraph();
  drawTree();
  drawStack();
  resetSimulation();
  document.getElementById('stepBtn').disabled = false;
}

function getPositions(canvasWidth, canvasHeight) {
  let positions = {};
  
  if (currentGraphType === 'default1' && vertices.length === 10) {
    // Layout ajustado do Padr√£o 1 - deslocado para a esquerda
    let scale = canvasWidth / 650;
    positions = {
      1: { x: 166 * scale, y: 120 },
      9: { x: 74 * scale, y: 180 },
      5: { x: 166 * scale, y: 240 },
      4: { x: 294 * scale, y: 180 },
      6: { x: 386 * scale, y: 80 },
      8: { x: 478 * scale, y: 120 },
      10: { x: 598 * scale, y: 120 },
      2: { x: 478 * scale, y: 220 },
      7: { x: 386 * scale, y: 280 },
      3: { x: 598 * scale, y: 240 }
    };
  } else if (currentGraphType === 'default2' && vertices.length === 8) {
    let scale = canvasWidth / 650;
    positions = {
      1: { x: 325 * scale, y: 80 },
      2: { x: 200 * scale, y: 180 },
      3: { x: 450 * scale, y: 180 },
      4: { x: 120 * scale, y: 280 },
      5: { x: 280 * scale, y: 280 },
      6: { x: 370 * scale, y: 280 },
      7: { x: 530 * scale, y: 280 },
      8: { x: 325 * scale, y: 380 }
    };
  } else {
    let centerX = canvasWidth / 2;
    let centerY = canvasHeight / 2;
    let circleRadius = Math.min(centerX, centerY) - 50;
    let n = vertices.length;
    
    for (let i = 0; i < n; i++) {
      let angle = (2 * Math.PI * i) / n - Math.PI / 2;
      positions[vertices[i]] = {
        x: centerX + circleRadius * Math.cos(angle),
        y: centerY + circleRadius * Math.sin(angle)
      };
    }
  }
  
  return positions;
}

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  let radius = 20;
  let positions = getPositions(canvas.width, canvas.height);
  
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  let drawnEdges = new Set();
  
  for (let [from, to] of edges) {
    let edgeKey = from < to ? `${from}-${to}` : `${to}-${from}`;
    if (drawnEdges.has(edgeKey)) continue;
    drawnEdges.add(edgeKey);
    
    let fromPos = positions[from];
    let toPos = positions[to];
    
    ctx.beginPath();
    ctx.moveTo(fromPos.x, fromPos.y);
    ctx.lineTo(toPos.x, toPos.y);
    ctx.stroke();
  }
  
  for (let v of vertices) {
    let pos = positions[v];
    
    if (marked[v]) {
      ctx.fillStyle = '#4CAF50';
    } else if (currentVertex === v) {
      ctx.fillStyle = '#FFC107';
    } else if (stack.includes(v)) {
      ctx.fillStyle = '#FF9800';
    } else {
      ctx.fillStyle = '#fff';
    }
    
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    
    ctx.fillStyle = '#000';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(v, pos.x, pos.y);
    
    if (expl[v] !== undefined) {
      ctx.fillStyle = '#c62828';
      ctx.font = 'bold 14px Arial';
      ctx.fillText(expl[v], pos.x + 25, pos.y - 5);
    }
  }
}

function drawGraphOnCanvas(context, canvasObj, state) {
  let canvasWidth = canvasObj.width;
  let canvasHeight = canvasObj.height;
  context.clearRect(0, 0, canvasWidth, canvasHeight);
  
  let radius = 18;
  let positions = getPositions(canvasWidth, canvasHeight);
  
  context.strokeStyle = '#666';
  context.lineWidth = 2;
  let drawnEdges = new Set();
  
  for (let [from, to] of edges) {
    let edgeKey = from < to ? `${from}-${to}` : `${to}-${from}`;
    if (drawnEdges.has(edgeKey)) continue;
    drawnEdges.add(edgeKey);
    
    let fromPos = positions[from];
    let toPos = positions[to];
    
    context.beginPath();
    context.moveTo(fromPos.x, fromPos.y);
    context.lineTo(toPos.x, toPos.y);
    context.stroke();
  }
  
  for (let v of vertices) {
    let pos = positions[v];
    
    if (state.marked[v]) {
      context.fillStyle = '#4CAF50';
    } else if (state.currentVertex === v) {
      context.fillStyle = '#FFC107';
    } else if (state.stack.includes(v)) {
      context.fillStyle = '#FF9800';
    } else {
      context.fillStyle = '#fff';
    }
    
    context.strokeStyle = '#333';
    context.lineWidth = 2;
    context.beginPath();
    context.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    
    context.fillStyle = '#000';
    context.font = 'bold 14px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(v, pos.x, pos.y);
    
    if (state.expl[v] !== undefined) {
      context.fillStyle = '#c62828';
      context.font = 'bold 12px Arial';
      context.fillText(state.expl[v], pos.x + 22, pos.y - 5);
    }
  }
}

function drawTree() {
  if (treeEdges.length === 0) {
    treeCanvas.height = 500;
    treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
    treeCtx.fillStyle = '#999';
    treeCtx.font = '14px Arial';
    treeCtx.textAlign = 'center';
    treeCtx.fillText('√Årvore ser√° constru√≠da durante a explora√ß√£o', treeCanvas.width / 2, treeCanvas.height / 2);
    return;
  }
  
  let radius = 20;
  let positions = calculateTreePositions();
  
  let maxY = 0;
  for (let v in positions) {
    if (positions[v].y > maxY) maxY = positions[v].y;
  }
  
  let canvasHeight = Math.max(500, maxY + 100);
  treeCanvas.height = canvasHeight;
  
  treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
  
  treeCtx.strokeStyle = '#FF9800';
  treeCtx.lineWidth = 2;
  
  for (let [from, to] of treeEdges) {
    let fromPos = positions[from];
    let toPos = positions[to];
    
    if (!fromPos || !toPos) continue;
    
    treeCtx.beginPath();
    treeCtx.moveTo(fromPos.x, fromPos.y);
    treeCtx.lineTo(toPos.x, toPos.y);
    treeCtx.stroke();
  }
  
  for (let v of vertices) {
    if (!positions[v]) continue;
    
    let pos = positions[v];
    
    if (expl[v] !== undefined) {
      treeCtx.fillStyle = '#4CAF50';
    } else {
      treeCtx.fillStyle = '#fff';
    }
    
    treeCtx.strokeStyle = '#333';
    treeCtx.lineWidth = 2;
    treeCtx.beginPath();
    treeCtx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    treeCtx.fill();
    treeCtx.stroke();
    
    treeCtx.fillStyle = '#000';
    treeCtx.font = 'bold 16px Arial';
    treeCtx.textAlign = 'center';
    treeCtx.textBaseline = 'middle';
    treeCtx.fillText(v, pos.x, pos.y);
  }
}

function drawTreeOnCanvas(context, canvasObj, state) {
  let canvasWidth = canvasObj.width;
  let canvasHeight = canvasObj.height;
  
  if (state.treeEdges.length === 0) {
    canvasObj.height = canvasHeight;
    context.clearRect(0, 0, canvasWidth, canvasHeight);
    context.fillStyle = '#999';
    context.font = '12px Arial';
    context.textAlign = 'center';
    context.fillText('√Årvore em constru√ß√£o...', canvasWidth / 2, canvasHeight / 2);
    return;
  }
  
  let radius = 18;
  let positions = calculateTreePositionsForCanvas(canvasWidth, state);
  
  let maxY = 0;
  for (let v in positions) {
    if (positions[v].y > maxY) maxY = positions[v].y;
  }
  
  let newHeight = Math.max(canvasHeight, maxY + 80);
  canvasObj.height = newHeight;
  
  context.clearRect(0, 0, canvasWidth, newHeight);
  
  context.strokeStyle = '#FF9800';
  context.lineWidth = 2;
  
  for (let [from, to] of state.treeEdges) {
    let fromPos = positions[from];
    let toPos = positions[to];
    if (!fromPos || !toPos) continue;
    
    context.beginPath();
    context.moveTo(fromPos.x, fromPos.y);
    context.lineTo(toPos.x, toPos.y);
    context.stroke();
  }
  
  for (let v of vertices) {
    if (!positions[v]) continue;
    let pos = positions[v];
    
    context.fillStyle = state.expl[v] !== undefined ? '#4CAF50' : '#fff';
    context.strokeStyle = '#333';
    context.lineWidth = 2;
    context.beginPath();
    context.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    
    context.fillStyle = '#000';
    context.font = 'bold 14px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(v, pos.x, pos.y);
  }
}

function calculateTreePositions() {
  let positions = {};
  let levels = {};
  let levelCounts = {};
  
  for (let v of vertices) {
    if (expl[v] === 1) {
      levels[v] = 0;
      break;
    }
  }
  
  for (let [from, to] of treeEdges) {
    if (levels[from] !== undefined) {
      levels[to] = levels[from] + 1;
    }
  }
  
  for (let v in levels) {
    let level = levels[v];
    if (!levelCounts[level]) levelCounts[level] = 0;
    levelCounts[level]++;
  }
  
  let levelIndices = {};
  let verticalSpacing = 80;
  let startY = 50;
  
  for (let v in levels) {
    let level = levels[v];
    if (!levelIndices[level]) levelIndices[level] = 0;
    
    let totalInLevel = levelCounts[level];
    let horizontalSpacing = treeCanvas.width / (totalInLevel + 1);
    
    positions[v] = {
      x: horizontalSpacing * (levelIndices[level] + 1),
      y: startY + level * verticalSpacing
    };
    
    levelIndices[level]++;
  }
  
  return positions;
}

function calculateTreePositionsForCanvas(canvasWidth, state) {
  let positions = {};
  let levels = {};
  let levelCounts = {};
  
  for (let v of vertices) {
    if (state.expl[v] === 1) {
      levels[v] = 0;
      break;
    }
  }
  
  for (let [from, to] of state.treeEdges) {
    if (levels[from] !== undefined) {
      levels[to] = levels[from] + 1;
    }
  }
  
  for (let v in levels) {
    let level = levels[v];
    if (!levelCounts[level]) levelCounts[level] = 0;
    levelCounts[level]++;
  }
  
  let levelIndices = {};
  let verticalSpacing = 70;
  let startY = 40;
  
  for (let v in levels) {
    let level = levels[v];
    if (!levelIndices[level]) levelIndices[level] = 0;
    
    let totalInLevel = levelCounts[level];
    let horizontalSpacing = canvasWidth / (totalInLevel + 1);
    
    positions[v] = {
      x: horizontalSpacing * (levelIndices[level] + 1),
      y: startY + level * verticalSpacing
    };
    
    levelIndices[level]++;
  }
  
  return positions;
}

function drawStack() {
  stackCtx.clearRect(0, 0, stackCanvas.width, stackCanvas.height);
  
  let labelText = dfsVersion === 'recursive' ? 'Pilha de Chamadas (DFS recursivo):' : 'Pilha (Stack):';
  stackCtx.fillStyle = '#333';
  stackCtx.font = 'bold 16px Arial';
  stackCtx.textAlign = 'left';
  stackCtx.fillText(labelText, 20, 25);
  
  if (stack.length === 0) {
    stackCtx.fillStyle = '#999';
    stackCtx.font = '14px Arial';
    stackCtx.fillText('[ vazia ]', 350, 25);
    return;
  }
  
  let boxWidth = 70;
  let boxHeight = 60;
  let startX = 100;
  let startY = 50;
  let spacing = 5;
  
  stackCtx.fillStyle = '#666';
  stackCtx.font = '12px Arial';
  stackCtx.textAlign = 'right';
  stackCtx.fillText('BOTTOM', startX - 10, startY + boxHeight / 2);
  
  for (let i = 0; i < stack.length; i++) {
    let x = startX + i * (boxWidth + spacing);
    
    if (i === stack.length - 1) {
      stackCtx.fillStyle = '#FF9800';
    } else {
      stackCtx.fillStyle = '#FFB74D';
    }
    
    stackCtx.fillRect(x, startY, boxWidth, boxHeight);
    
    stackCtx.strokeStyle = '#F57C00';
    stackCtx.lineWidth = 2;
    stackCtx.strokeRect(x, startY, boxWidth, boxHeight);
    
    stackCtx.fillStyle = '#000';
    stackCtx.font = '12px Arial';
    stackCtx.textAlign = 'center';
    stackCtx.textBaseline = 'top';
    
    if (dfsVersion === 'recursive') {
      stackCtx.fillText('DFS', x + boxWidth / 2, startY + 10);
    }
    
    stackCtx.font = 'bold 20px Arial';
    stackCtx.textBaseline = 'middle';
    let yOffset = dfsVersion === 'recursive' ? startY + boxHeight / 2 + 5 : startY + boxHeight / 2;
    stackCtx.fillText(stack[i], x + boxWidth / 2, yOffset);
  }
  
  let lastX = startX + (stack.length - 1) * (boxWidth + spacing);
  stackCtx.fillStyle = '#666';
  stackCtx.font = '12px Arial';
  stackCtx.textAlign = 'left';
  stackCtx.fillText('TOP', lastX + boxWidth + 10, startY + boxHeight / 2);
}

function drawStackOnCanvas(context, canvasObj, state, isRecursive) {
  context.clearRect(0, 0, canvasObj.width, canvasObj.height);
  
  if (state.stack.length === 0) {
    context.fillStyle = '#999';
    context.font = '14px Arial';
    context.textAlign = 'center';
    context.fillText('[ vazia ]', canvasObj.width / 2, 80);
    return;
  }
  
  let boxWidth = 65;
  let boxHeight = 55;
  let startX = 80;
  let startY = 50;
  let spacing = 5;
  
  context.fillStyle = '#666';
  context.font = '11px Arial';
  context.textAlign = 'right';
  context.fillText('BOTTOM', startX - 10, startY + boxHeight / 2);
  
  for (let i = 0; i < state.stack.length; i++) {
    let x = startX + i * (boxWidth + spacing);
    
    context.fillStyle = i === state.stack.length - 1 ? '#FF9800' : '#FFB74D';
    context.fillRect(x, startY, boxWidth, boxHeight);
    
    context.strokeStyle = '#F57C00';
    context.lineWidth = 2;
    context.strokeRect(x, startY, boxWidth, boxHeight);
    
    context.fillStyle = '#000';
    context.font = '11px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'top';
    
    if (isRecursive) {
      context.fillText('DFS', x + boxWidth / 2, startY + 8);
    }
    
    context.font = 'bold 18px Arial';
    context.textBaseline = 'middle';
    let yOffset = isRecursive ? startY + boxHeight / 2 + 5 : startY + boxHeight / 2;
    context.fillText(state.stack[i], x + boxWidth / 2, yOffset);
  }
  
  let lastX = startX + (state.stack.length - 1) * (boxWidth + spacing);
  context.fillStyle = '#666';
  context.font = '11px Arial';
  context.textAlign = 'left';
  context.fillText('TOP', lastX + boxWidth + 10, startY + boxHeight / 2);
}

function stepSimulation() {
  if (comparisonMode) {
    stepComparisonMode();
  } else {
    stepSingleMode();
  }
}

function stepSingleMode() {
  if (stepIndex >= steps.length) return;
  
  if (!simulationStarted) {
    simulationStarted = true;
    document.getElementById('stateDisplay').style.display = 'block';
  }
  
  let step = steps[stepIndex];
  executeStep(step, { marked, expl, stack, cont, currentVertex, treeEdges, treeParent });
  
  if (step.message) {
    outputText += step.message + '\n';
    document.getElementById('output').textContent = outputText;
    document.getElementById('output').scrollTop = document.getElementById('output').scrollHeight;
  }
  
  stepIndex++;
  
  drawGraph();
  drawTree();
  drawStack();
  
  updateSingleModeDisplay();
}

function stepComparisonMode() {
  let hasRecStep = stateRec.stepIndex < stateRec.steps.length;
  let hasIterStep = stateIter.stepIndex < stateIter.steps.length;
  
  if (!hasRecStep && !hasIterStep) return;
  
  if (hasRecStep) {
    let step = stateRec.steps[stateRec.stepIndex];
    executeStep(step, stateRec);
    
    if (step.message) {
      stateRec.output += step.message + '\n';
      document.getElementById('output-rec').textContent = stateRec.output;
      document.getElementById('output-rec').scrollTop = document.getElementById('output-rec').scrollHeight;
    }
    
    stateRec.stepIndex++;
  }
  
  if (hasIterStep) {
    let step = stateIter.steps[stateIter.stepIndex];
    executeStep(step, stateIter);
    
    if (step.message) {
      stateIter.output += step.message + '\n';
      document.getElementById('output-iter').textContent = stateIter.output;
      document.getElementById('output-iter').scrollTop = document.getElementById('output-iter').scrollHeight;
    }
    
    stateIter.stepIndex++;
  }
  
  drawGraphOnCanvas(ctxRec, canvasRec, stateRec);
  drawTreeOnCanvas(treeCtxRec, treeCanvasRec, stateRec);
  drawStackOnCanvas(stackCtxRec, stackCanvasRec, stateRec, true);
  
  drawGraphOnCanvas(ctxIter, canvasIter, stateIter);
  drawTreeOnCanvas(treeCtxIter, treeCanvasIter, stateIter);
  drawStackOnCanvas(stackCtxIter, stackCanvasIter, stateIter, false);
  
  updateComparisonDisplay();
}

function executeStep(step, state) {
  switch(step.type) {
    case 'push':
      state.stack.push(step.v);
      state.currentVertex = step.v;
      break;
    case 'top':
      state.currentVertex = step.v;
      break;
    case 'pop':
      state.stack.pop();
      state.currentVertex = state.stack.length > 0 ? state.stack[state.stack.length - 1] : null;
      break;
    case 'mark':
      state.marked[step.v] = true;
      break;
    case 'expl':
      state.expl[step.v] = step.cont;
      state.cont = step.cont;
      break;
    case 'tree_edge':
      state.treeEdges.push([step.from, step.to]);
      state.treeParent[step.to] = step.from;
      break;
    case 'complete':
      state.currentVertex = null;
      break;
  }
}

function updateSingleModeDisplay() {
  let varsHtml = `
    <div class="var-display"><strong>cont:</strong> ${cont}</div>
    <div class="var-display"><strong>${dfsVersion === 'recursive' ? 'Profundidade' : 'Tamanho'}:</strong> ${stack.length}</div>
  `;
  document.getElementById('variables').innerHTML = varsHtml;
  
  let stackDisplay = stack.map(v => dfsVersion === 'recursive' ? `DFS(${v})` : v).join(', ');
  document.getElementById('stackContent').textContent = '[' + stackDisplay + ']';
}

function updateComparisonDisplay() {
  document.getElementById('variables-rec').innerHTML = `
    <div class="var-display"><strong>cont:</strong> ${stateRec.cont}</div>
    <div class="var-display"><strong>Profundidade:</strong> ${stateRec.stack.length}</div>
  `;
  document.getElementById('stackContent-rec').textContent = '[' + stateRec.stack.map(v => `DFS(${v})`).join(', ') + ']';
  
  document.getElementById('variables-iter').innerHTML = `
    <div class="var-display"><strong>cont:</strong> ${stateIter.cont}</div>
    <div class="var-display"><strong>Tamanho:</strong> ${stateIter.stack.length}</div>
  `;
  document.getElementById('stackContent-iter').textContent = '[' + stateIter.stack.join(', ') + ']';
}

function resetSimulation() {
  simulationStarted = false;
  
  if (comparisonMode) {
    stateRec = { marked: {}, expl: {}, stack: [], cont: 0, currentVertex: null, treeEdges: [], treeParent: {}, steps: [], stepIndex: 0, output: '' };
    stateIter = { marked: {}, expl: {}, stack: [], cont: 0, currentVertex: null, treeEdges: [], treeParent: {}, steps: [], stepIndex: 0, output: '' };
    
    prepareSteps('recursive', stateRec);
    prepareSteps('iterative', stateIter);
    
    document.getElementById('output-rec').textContent = '';
    document.getElementById('output-iter').textContent = '';
    
    drawGraphOnCanvas(ctxRec, canvasRec, stateRec);
    drawTreeOnCanvas(treeCtxRec, treeCanvasRec, stateRec);
    drawStackOnCanvas(stackCtxRec, stackCanvasRec, stateRec, true);
    
    drawGraphOnCanvas(ctxIter, canvasIter, stateIter);
    drawTreeOnCanvas(treeCtxIter, treeCanvasIter, stateIter);
    drawStackOnCanvas(stackCtxIter, stackCanvasIter, stateIter, false);
  } else {
    marked = {}; expl = {}; stack = []; cont = 0; currentVertex = null;
    steps = []; stepIndex = 0;
    treeEdges = []; treeParent = {}; outputText = '';
    
    document.getElementById('stateDisplay').style.display = 'none';
    document.getElementById('output').textContent = '';
    
    prepareSteps(dfsVersion, { marked, expl, stack, cont, currentVertex, treeEdges, treeParent, steps, stepIndex });
    
    drawGraph();
    drawTree();
    drawStack();
  }
}

function prepareSteps(version, state) {
  state.steps = [];
  
  if (version === 'recursive') {
    state.steps.push({ type: 'init', message: 'cont = 0' });
    state.steps.push({ type: 'unmark_all', message: 'Desmarcar todos os v√©rtices' });
    state.steps.push({ type: 'call_dfs', v: 1, message: 'Chamar DFS(1)' });
    
    let tempMarked = {}, tempExpl = {}, counter = { value: 0 };
    simulateDFSRecursive(1, tempMarked, tempExpl, counter, state.steps, 0);
    
    state.steps.push({ type: 'complete', message: 'DFS completo!' });
  } else {
    state.steps.push({ type: 'unmark_all', message: 'Desmarcar todos os v√©rtices' });
    state.steps.push({ type: 'init_stack', message: 'Criar pilha P' });
    state.steps.push({ type: 'init', message: 'cont = 0' });
    state.steps.push({ type: 'mark', v: 1, message: 'Marcar v√©rtice 1' });
    state.steps.push({ type: 'push', v: 1, message: 'push(P, 1)' });
    
    let tempMarked = { 1: true }, tempExpl = {}, tempCont = 0, tempStack = [1];
    
    while (tempStack.length > 0) {
      let curr = tempStack[tempStack.length - 1];
      state.steps.push({ type: 'top', v: curr, message: `curr = top(P) = ${curr}` });
      state.steps.push({ type: 'pop', v: curr, message: `pop(P)` });
      tempStack.pop();
      
      tempCont++;
      state.steps.push({ type: 'expl', v: curr, cont: tempCont, message: `expl[${curr}] = ++cont = ${tempCont}` });
      state.steps.push({ type: 'explore', v: curr, message: `Explorando v√©rtice ${curr}` });
      
      let adjacents = [...adjList[curr]].reverse();
      
      for (let u of adjacents) {
        if (!tempMarked[u]) {
          tempMarked[u] = true;
          tempStack.push(u);
          
          state.steps.push({ type: 'check_unmarked', from: curr, to: u, message: `Aresta <${curr},${u}>: ${u} est√° desmarcado` });
          state.steps.push({ type: 'mark', v: u, message: `Marcar v√©rtice ${u}` });
          state.steps.push({ type: 'tree_edge', from: curr, to: u, message: `Adicionar aresta ${curr}->${u} √† √°rvore` });
          state.steps.push({ type: 'push', v: u, message: `push(P, ${u})` });
        }
      }
    }
    
    state.steps.push({ type: 'complete', message: 'DFS completo!' });
  }
}

function simulateDFSRecursive(v, tempMarked, tempExpl, counter, steps, depth) {
  steps.push({ type: 'push', v: v, message: `  ${'  '.repeat(depth)}Entrar em DFS(${v})` });
  steps.push({ type: 'mark', v: v, message: `  ${'  '.repeat(depth)}Marcar v√©rtice ${v}` });
  tempMarked[v] = true;
  
  counter.value++;
  steps.push({ type: 'expl', v: v, cont: counter.value, message: `  ${'  '.repeat(depth)}expl[${v}] = ++cont = ${counter.value}` });
  steps.push({ type: 'explore', v: v, message: `  ${'  '.repeat(depth)}Explorando v√©rtice ${v}` });
  
  for (let u of adjList[v]) {
    if (!tempMarked[u]) {
      steps.push({ type: 'check_unmarked', from: v, to: u, message: `  ${'  '.repeat(depth)}Aresta <${v},${u}>: ${u} est√° desmarcado` });
      steps.push({ type: 'tree_edge', from: v, to: u, message: `  ${'  '.repeat(depth)}Adicionar aresta ${v}->${u} √† √°rvore` });
      steps.push({ type: 'recursive_call', v: u, message: `  ${'  '.repeat(depth)}Chamar DFS(${u})` });
      
      simulateDFSRecursive(u, tempMarked, tempExpl, counter, steps, depth + 1);
      
      steps.push({ type: 'return_from', v: u, message: `  ${'  '.repeat(depth)}Retornar de DFS(${u})` });
    } else {
      steps.push({ type: 'check_marked', from: v, to: u, message: `  ${'  '.repeat(depth)}Aresta <${v},${u}>: ${u} j√° marcado` });
    }
  }
  
  steps.push({ type: 'pop', v: v, message: `  ${'  '.repeat(depth)}Sair de DFS(${v})` });
}

window.onload = init;
</script>

</body>
</html>
